# Stage 1 – Baseline Vulnerability Assessment

## Overview
The Spring Boot reference application intentionally ships with insecure components so you can practice documenting risks before remediation. Focus on the Java sources under:

- `src/main/java/com/github/copilot/lab/controller/AuthControllerVulnerable.java`
- `src/main/java/com/github/copilot/lab/service/FileStorageServiceVulnerable.java`
- `src/main/java/com/github/copilot/lab/controller/ReportControllerVulnerable.java`

Each file carries multiple governance-relevant weaknesses. Your goal is to catalogue the risks, tie them back to guardrails from `.github/copilot-instructions.md`, and outline the remediation strategy before the code is touched.

## Vulnerabilities Included

### AuthControllerVulnerable.java
1. **Plain-Text Credential Handling** – Accepts credentials over HTTP without enforcing HTTPS or hashing, then logs the raw username and password (`log.info`).
2. **Insecure Password Verification** – Compares passwords with `equals` against records stored in clear text instead of delegating to a password encoder.
3. **Missing Brute-Force Controls** – Login endpoint has no rate limiting or account lockout logic.
4. **Session Fixation Risk** – Reuses existing session identifiers on login rather than regenerating them.
5. **JWT Misconfiguration** – Generates unsigned JWTs with `alg=none` and no expiration claim before returning them to clients.
6. **Verbose Error Messages** – Returns stack traces and credential hints in the response body on authentication failure.

### FileStorageServiceVulnerable.java
1. **Path Traversal** – Joins user-supplied filenames directly with the storage root (`Paths.get(uploadDir, fileName)`), allowing `../` sequences to escape the intended folder.
2. **Unbounded Upload Size** – Streams files straight to disk without checking content length.
3. **Unsafe File Types** – Accepts every MIME type and stores executable content inside `src/main/resources/static/uploads`.
4. **Insufficient Logging Hygiene** – Logs absolute file paths and request headers (including cookies) at INFO level.
5. **No Antivirus Scanning** – Saves files without scanning or quarantine hooks, despite configuration placeholder claiming otherwise.
6. **Synchronous Disk Writes** – Performs blocking IO on the Web thread without timeouts or error translation, exposing internal exceptions.

### ReportControllerVulnerable.java
1. **SQL Injection** – Concatenates the `reportId` request parameter into a SQL string (`"SELECT * FROM reports WHERE id = " + id`).
2. **Unvalidated Export Format** – Accepts `format` query parameter and passes it directly to a file exporter, enabling arbitrary class loading.
3. **Thymeleaf XSS** – Renders unescaped user data with `model.addAttribute("content", reportEntity.getHtml())` and uses `th:utext` in the template.
4. **Unsecured File Download** – Streams files from disk without verifying the current user’s permissions.
5. **Verbose Logging** – Logs the raw SQL query and report metadata, including personally identifiable information.
6. **Lack of Audit Trail** – Does not persist who accessed or exported sensitive reports, conflicting with governance expectations.

## Stage Goals
- Produce an executive summary of the risk posture for these components.
- Map each vulnerability to OWASP Top 10 categories and identify impacted controls.
- Link every remediation requirement back to guardrails in `.github/copilot-instructions.md` (validation, logging, secure defaults, quality gates).
- Decide which Maven quality gates (clean, test, verify, dependency:tree, scripts) will be used to prove mitigation in later stages.

## Recommended Actions (Stage 1)
1. Switch Copilot Chat to **Plan Mode** and prompt it for a structured risk catalogue covering all three files (vulnerabilities, affected assets, impact, likelihood).
2. Persist the write-up in `docs/plans/stage1-plan.md` (or an equivalent file under `docs/plans/`) so downstream stages inherit your findings.
3. Highlight mandatory governance artifacts—`VULNERABILITIES.md`, `FIXES.md`, `COPILOT_USAGE.md`, updated `docs/workflow-tracker.md`, and `governance-report.md`—that must be completed before the workflow ends.
4. Transition to Stage 2 only after the draft plan is reviewed in **Validation Mode** and remediation scope/sign-off criteria are documented.

---

## Stage 2 – Remediation Guidelines

Once the assessment is complete, remediate these files **in place** using Copilot-guided iterations:

1. Launch **Plan Mode** again to break the remediation work into actionable slices. Capture the steps in `docs/plans/stage2-plan.md` (or similar) and log assumptions + risks inside `docs/workflow-tracker.md`.
2. Refactor each vulnerable class in situ (do not duplicate files). Remove the `Vulnerable` suffix only after the code satisfies guardrails and automated tests cover the changes.
3. Validate fixes against `.github/copilot-instructions.md`:
   - Controllers must use `@Valid` DTOs, regenerate sessions, avoid leaking secrets.
   - Services must normalize file paths, enforce allow-lists, and keep logging sanitized.
   - Database access must rely on prepared statements or Spring Data repositories.
   - Templates must render via `th:text` unless explicitly escaped.
4. Record Maven commands and outcomes in `docs/test-coverage.md` (`mvn clean`, `mvn test`, `mvn verify`, `mvn dependency:tree`, `./scripts/run-all-checks.sh`, etc.). Note coverage deltas and residual risks.
5. Document completed work, outstanding items, and evidence locations in `docs/workflow-tracker.md` before advancing to Stage 3.
